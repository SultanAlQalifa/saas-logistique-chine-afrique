/**
 * Service centralis√© pour l'agent IA dans tous les contextes de chat
 * Int√®gre l'intelligence artificielle dans support client, widget et tickets
 */

import { IntelligentChatbot } from './intelligent-chatbot'
import { WebSearchService } from './web-search-service'

export interface ChatMessage {
  id: string
  type: 'user' | 'bot' | 'agent'
  content: string
  timestamp: Date
  isTyping?: boolean
  actions?: Array<{
    label: string
    action: string
    variant?: 'primary' | 'secondary'
    data?: any
  }>
  metadata?: {
    ticketId?: string
    userId?: string
    sessionId?: string
    context?: 'support' | 'widget' | 'ticket' | 'whatsapp'
    searchResults?: any[]
  }
}

export interface ChatContext {
  userId?: string
  ticketId?: string
  sessionId: string
  context: 'support' | 'widget' | 'ticket' | 'whatsapp'
  userType: 'particulier' | 'entreprise'
  language: 'fr' | 'en'
  previousMessages: ChatMessage[]
  ticketData?: any
  clientInfo?: {
    name?: string
    email?: string
    phone?: string
    company?: string
  }
}

export interface AIResponse {
  message: string
  actions?: Array<{
    label: string
    action: string
    variant?: 'primary' | 'secondary'
    data?: any
  }>
  suggestions?: string[]
  shouldEscalate?: boolean
  escalationReason?: string
  metadata?: {
    searchPerformed?: boolean
    sources?: string[]
    confidence?: number
  }
}

export class AIChatService {
  private static instance: AIChatService
  private chatbot: IntelligentChatbot
  private webSearch: WebSearchService
  private activeSessions: Map<string, ChatContext> = new Map()

  private constructor() {
    this.chatbot = IntelligentChatbot.getInstance()
    this.webSearch = WebSearchService.getInstance()
  }

  static getInstance(): AIChatService {
    if (!AIChatService.instance) {
      AIChatService.instance = new AIChatService()
    }
    return AIChatService.instance
  }

  /**
   * Traiter un message dans n'importe quel contexte de chat
   */
  async processMessage(
    message: string,
    context: ChatContext
  ): Promise<AIResponse> {
    try {
      // Mettre √† jour la session active
      this.activeSessions.set(context.sessionId, context)

      // Analyser le message selon le contexte
      const response = await this.analyzeAndRespond(message, context)

      // Logger l'interaction pour analytics
      this.logInteraction(message, response, context)

      return response
    } catch (error) {
      console.error('Erreur traitement message IA:', error)
      return this.getErrorResponse(context)
    }
  }

  private async analyzeAndRespond(
    message: string,
    context: ChatContext
  ): Promise<AIResponse> {
    // D√©tecter l'intention selon le contexte
    const intent = this.detectIntent(message, context)

    switch (intent) {
      case 'create_ticket':
        return this.handleTicketCreation(message, context)
      
      case 'track_package':
        return this.handlePackageTracking(message, context)
      
      case 'pricing_inquiry':
        return this.handlePricingInquiry(message, context)
      
      case 'complaint':
        return this.handleComplaint(message, context)
      
      case 'general_question':
        return this.handleGeneralQuestion(message, context)
      
      case 'escalate_to_human':
        return this.handleHumanEscalation(message, context)
      
      default:
        return this.handleUnknownIntent(message, context)
    }
  }

  private detectIntent(message: string, context: ChatContext): string {
    const lowerMessage = message.toLowerCase()

    // D√©tection bas√©e sur les mots-cl√©s et le contexte
    if (lowerMessage.includes('ticket') || lowerMessage.includes('probl√®me') || lowerMessage.includes('signaler')) {
      return 'create_ticket'
    }

    if (lowerMessage.includes('suivre') || lowerMessage.includes('tracking') || /[A-Z]{2,3}[0-9]{6,}/.test(message)) {
      return 'track_package'
    }

    if (lowerMessage.includes('prix') || lowerMessage.includes('tarif') || lowerMessage.includes('devis')) {
      return 'pricing_inquiry'
    }

    if (lowerMessage.includes('r√©clamation') || lowerMessage.includes('plainte') || lowerMessage.includes('insatisfait')) {
      return 'complaint'
    }

    if (lowerMessage.includes('agent') || lowerMessage.includes('humain') || lowerMessage.includes('personne')) {
      return 'escalate_to_human'
    }

    return 'general_question'
  }

  private async handleTicketCreation(message: string, context: ChatContext): Promise<AIResponse> {
    return {
      message: `üé´ **Cr√©ation de ticket** - Je vais vous aider √† cr√©er un ticket de support.

Pour traiter votre demande efficacement, j'ai besoin de quelques informations :

üìù **Cat√©gorie du probl√®me** :
‚Ä¢ Livraison (retard, colis perdu)
‚Ä¢ Facturation (erreur, paiement)
‚Ä¢ R√©clamation (dommage, qualit√©)
‚Ä¢ Devis (demande de prix)
‚Ä¢ Autre

Pouvez-vous me pr√©ciser la nature de votre probl√®me ?`,
      actions: [
        { label: 'üì¶ Probl√®me de livraison', action: 'ticket_category_livraison', variant: 'primary' },
        { label: 'üí∞ Question facturation', action: 'ticket_category_facturation', variant: 'secondary' },
        { label: '‚ö†Ô∏è R√©clamation', action: 'ticket_category_reclamation', variant: 'secondary' },
        { label: 'üìã Demande de devis', action: 'ticket_category_devis', variant: 'secondary' }
      ]
    }
  }

  private async handlePackageTracking(message: string, context: ChatContext): Promise<AIResponse> {
    // Extraire le num√©ro de tracking s'il existe
    const trackingMatch = message.match(/[A-Z]{2,3}[0-9]{6,}/g)
    
    if (trackingMatch) {
      const trackingNumber = trackingMatch[0]
      return {
        message: `üì¶ **Suivi du colis ${trackingNumber}**

üîç Recherche en cours...

**Statut actuel** : En transit maritime
**Derni√®re position** : Port de Shanghai
**Prochaine √©tape** : D√©douanement Dakar
**Livraison estim√©e** : 3-5 jours

üìç **Historique** :
‚Ä¢ ‚úÖ Collect√© √† Shanghai (12/01)
‚Ä¢ ‚úÖ Embarqu√© navire cargo (14/01)
‚Ä¢ üö¢ En transit maritime (actuel)
‚Ä¢ ‚è≥ Arriv√©e port Dakar (pr√©vu 18/01)`,
        actions: [
          { label: 'üì± Recevoir SMS de suivi', action: 'enable_sms_tracking', variant: 'primary' },
          { label: 'üìß Notifications email', action: 'enable_email_tracking', variant: 'secondary' },
          { label: 'üìû Contacter transporteur', action: 'contact_carrier', variant: 'secondary' }
        ]
      }
    }

    return {
      message: `üì¶ **Suivi de colis** - Pour suivre votre exp√©dition, j'ai besoin du num√©ro de tracking.

**Format attendu** : ABC123456 ou NM789012

Vous pouvez le trouver :
‚Ä¢ Dans l'email de confirmation d'exp√©dition
‚Ä¢ Sur votre facture NextMove
‚Ä¢ Dans votre espace client

Pouvez-vous me communiquer votre num√©ro de suivi ?`,
      actions: [
        { label: 'üîç Rechercher dans mes exp√©ditions', action: 'search_my_shipments', variant: 'primary' },
        { label: 'üìß Renvoyer email confirmation', action: 'resend_confirmation', variant: 'secondary' }
      ]
    }
  }

  private async handlePricingInquiry(message: string, context: ChatContext): Promise<AIResponse> {
    // Recherche web pour tarifs actualis√©s
    const searchResults = await this.webSearch.search(`tarifs transport international Chine Afrique ${message}`, {
      maxResults: 3,
      language: 'fr'
    })

    let webInfo = ''
    if (searchResults.results.length > 0) {
      webInfo = `\n\nüåê **Informations march√© actuelles** :\n${searchResults.results[0].snippet}`
    }

    return {
      message: `üí∞ **Calcul de tarifs** - Je peux vous aider √† estimer le co√ªt de votre exp√©dition.

**Informations n√©cessaires** :
‚Ä¢ **Origine** : Ville de d√©part en Chine
‚Ä¢ **Destination** : Ville d'arriv√©e en Afrique
‚Ä¢ **Poids** : En kilogrammes
‚Ä¢ **Volume** : En m¬≥ ou dimensions (L√ól√óh)
‚Ä¢ **Type de marchandise** : Pour v√©rifications douani√®res

**Nos tarifs moyens** :
üö¢ **Maritime** : 180-250‚Ç¨/m¬≥ (25-35 jours)
‚úàÔ∏è **A√©rien** : 4-8‚Ç¨/kg (3-7 jours)
üöõ **Terrestre** : 120-180‚Ç¨/m¬≥ (15-25 jours)${webInfo}

Pouvez-vous me donner ces informations pour un devis pr√©cis ?`,
      actions: [
        { label: 'üßÆ Calculateur automatique', action: 'open_calculator', variant: 'primary' },
        { label: 'üìû Devis par t√©l√©phone', action: 'phone_quote', variant: 'secondary' },
        { label: 'üìä Comparer les modes', action: 'compare_shipping_modes', variant: 'secondary' }
      ],
      metadata: {
        searchPerformed: searchResults.results.length > 0,
        sources: searchResults.sources
      }
    }
  }

  private async handleComplaint(message: string, context: ChatContext): Promise<AIResponse> {
    return {
      message: `‚ö†Ô∏è **R√©clamation** - Je comprends votre pr√©occupation et vais vous aider √† r√©soudre ce probl√®me.

**Proc√©dure de r√©clamation** :
1. **Description d√©taill√©e** du probl√®me
2. **Photos** si dommages visibles
3. **Num√©ro de tracking** de l'exp√©dition
4. **Facture** ou preuve d'achat

**Types de r√©clamations courantes** :
‚Ä¢ Colis endommag√© ou cass√©
‚Ä¢ Livraison incompl√®te
‚Ä¢ Retard de livraison important
‚Ä¢ Probl√®me de qualit√©

Je vais cr√©er un ticket prioritaire pour votre r√©clamation. Pouvez-vous me d√©crire pr√©cis√©ment le probl√®me rencontr√© ?`,
      actions: [
        { label: 'üì∑ Ajouter des photos', action: 'add_photos', variant: 'primary' },
        { label: 'üö® R√©clamation urgente', action: 'urgent_complaint', variant: 'primary' },
        { label: 'üí¨ Parler √† un responsable', action: 'escalate_manager', variant: 'secondary' }
      ]
    }
  }

  private async handleGeneralQuestion(message: string, context: ChatContext): Promise<AIResponse> {
    // Utiliser le chatbot intelligent avec recherche web
    const chatbotResponse = await this.chatbot.processMessage(message, context.userId || 'anonymous')

    return {
      message: chatbotResponse.message,
      actions: chatbotResponse.actions?.map(action => ({
        label: action.label,
        action: action.type,
        data: action.data
      })),
      suggestions: chatbotResponse.suggestions,
      metadata: {
        searchPerformed: true,
        confidence: 0.8
      }
    }
  }

  private async handleHumanEscalation(message: string, context: ChatContext): Promise<AIResponse> {
    return {
      message: `ü§ù **Transfert vers un agent humain**

Je vous mets en relation avec un de nos experts qui pourra mieux vous aider.

**Informations transmises** :
‚Ä¢ Votre demande : "${message}"
‚Ä¢ Contexte : ${context.context}
‚Ä¢ Historique de conversation

**Temps d'attente estim√©** :
‚Ä¢ Support g√©n√©ral : 2-5 minutes
‚Ä¢ Support technique : 5-10 minutes
‚Ä¢ Support commercial : 1-3 minutes

Un agent va prendre en charge votre conversation dans quelques instants.`,
      actions: [
        { label: 'üìû Rappel imm√©diat', action: 'request_callback', variant: 'primary' },
        { label: 'üìß Email de suivi', action: 'send_follow_up_email', variant: 'secondary' }
      ],
      shouldEscalate: true,
      escalationReason: 'Demande explicite de contact humain'
    }
  }

  private async handleUnknownIntent(message: string, context: ChatContext): Promise<AIResponse> {
    // Recherche web pour tenter de r√©pondre
    const searchResults = await this.webSearch.search(`logistique transport ${message}`, {
      maxResults: 3,
      language: context.language
    })

    if (searchResults.results.length > 0) {
      return {
        message: `üîç **Recherche d'informations** - Voici ce que j'ai trouv√© :

${searchResults.results[0].snippet}

**Source** : ${searchResults.results[0].title}

Cette information r√©pond-elle √† votre question ? Sinon, je peux :`,
        actions: [
          { label: '‚úÖ Oui, merci', action: 'mark_resolved', variant: 'primary' },
          { label: 'üîç Chercher plus d\'infos', action: 'search_more', variant: 'secondary' },
          { label: 'üë®‚Äçüíº Parler √† un expert', action: 'escalate_to_human', variant: 'secondary' }
        ],
        metadata: {
          searchPerformed: true,
          sources: searchResults.sources
        }
      }
    }

    return {
      message: `ü§î Je n'ai pas bien saisi votre demande. Voici comment je peux vous aider :

**üîç Recherches populaires :**
‚Ä¢ "Suivre le colis ABC123456"
‚Ä¢ "Tarif Shanghai vers Dakar 100kg"
‚Ä¢ "Cr√©er un ticket de r√©clamation"
‚Ä¢ "Documents pour exporter en C√¥te d'Ivoire"

**üí° Ou choisissez directement :**`,
      actions: [
        { label: 'üì¶ Suivi de colis', action: 'track_package', variant: 'primary' },
        { label: 'üí∞ Calcul de tarifs', action: 'pricing_inquiry', variant: 'secondary' },
        { label: 'üé´ Cr√©er un ticket', action: 'create_ticket', variant: 'secondary' },
        { label: 'üë®‚Äçüíº Agent humain', action: 'escalate_to_human', variant: 'secondary' }
      ]
    }
  }

  private getErrorResponse(context: ChatContext): AIResponse {
    return {
      message: `‚ùå **Erreur temporaire** - D√©sol√©, je rencontre un probl√®me technique.

Un agent humain va prendre en charge votre demande imm√©diatement.

**En attendant, vous pouvez** :
‚Ä¢ R√©essayer dans quelques instants
‚Ä¢ Nous contacter par t√©l√©phone : +33 1 XX XX XX XX
‚Ä¢ Envoyer un email : support@nextmove.fr`,
      actions: [
        { label: 'üîÑ R√©essayer', action: 'retry', variant: 'primary' },
        { label: 'üìû Appeler maintenant', action: 'call_support', variant: 'secondary' }
      ],
      shouldEscalate: true,
      escalationReason: 'Erreur technique du chatbot'
    }
  }

  private logInteraction(message: string, response: AIResponse, context: ChatContext): void {
    // Logger pour analytics et am√©lioration continue
    console.log('AI Chat Interaction:', {
      timestamp: new Date(),
      context: context.context,
      userMessage: message,
      botResponse: response.message,
      searchPerformed: response.metadata?.searchPerformed,
      escalated: response.shouldEscalate
    })
  }

  /**
   * Obtenir le contexte d'une session active
   */
  getSessionContext(sessionId: string): ChatContext | undefined {
    return this.activeSessions.get(sessionId)
  }

  /**
   * Mettre √† jour le contexte d'une session
   */
  updateSessionContext(sessionId: string, updates: Partial<ChatContext>): void {
    const existing = this.activeSessions.get(sessionId)
    if (existing) {
      this.activeSessions.set(sessionId, { ...existing, ...updates })
    }
  }

  /**
   * Nettoyer les sessions inactives
   */
  cleanupInactiveSessions(): void {
    // Nettoyer les sessions de plus de 24h
    const cutoff = new Date(Date.now() - 24 * 60 * 60 * 1000)
    
    Array.from(this.activeSessions.entries()).forEach(([sessionId, context]) => {
      const lastMessage = context.previousMessages?.[context.previousMessages.length - 1]
      if (lastMessage && lastMessage.timestamp < cutoff) {
        this.activeSessions.delete(sessionId)
      }
    })
  }
}
